"""
Frontend Configuration Updater
Updates the frontend to use FastAPI backend instead of Next.js API routes
"""
import os
import re
import json
from pathlib import Path
from typing import Dict, List, Tuple

class FrontendConfigUpdater:
    """Updates frontend configuration to use FastAPI backend"""
    
    def __init__(self, frontend_dir: str = "../app", fastapi_port: int = 8000):
        self.frontend_dir = Path(frontend_dir)
        self.fastapi_port = fastapi_port
        self.fastapi_base_url = f"http://localhost:{fastapi_port}"
        self.changes_made = []
        
    def find_api_calls(self) -> List[Tuple[Path, List[str]]]:
        """Find all API calls in the frontend code"""
        api_calls = []
        
        # Common patterns for API calls
        patterns = [
            r'fetch\s*\(\s*[\'"`]/api/',
            r'axios\.\w+\s*\(\s*[\'"`]/api/',
            r'\.get\s*\(\s*[\'"`]/api/',
            r'\.post\s*\(\s*[\'"`]/api/',
            r'\.put\s*\(\s*[\'"`]/api/',
            r'\.delete\s*\(\s*[\'"`]/api/',
        ]
        
        # Search in JavaScript/TypeScript files
        for file_path in self.frontend_dir.rglob("*.js"):
            if "node_modules" in str(file_path) or ".next" in str(file_path):
                continue
                
            try:
                content = file_path.read_text(encoding='utf-8')
                matches = []
                
                for pattern in patterns:
                    for match in re.finditer(pattern, content, re.IGNORECASE):
                        matches.append(match.group())
                
                if matches:
                    api_calls.append((file_path, matches))
                    
            except Exception as e:
                print(f"Error reading {file_path}: {e}")
        
        return api_calls
    
    def update_api_calls_in_file(self, file_path: Path) -> bool:
        """Update API calls in a specific file to use FastAPI backend"""
        try:
            content = file_path.read_text(encoding='utf-8')
            original_content = content
            
            # Replace relative API calls with absolute FastAPI URLs
            patterns_replacements = [
                # fetch('/api/...') -> fetch('http://localhost:8000/api/...')
                (r'fetch\s*\(\s*[\'"`]/api/', f'fetch(`{self.fastapi_base_url}/api/'),
                # axios.get('/api/...') -> axios.get('http://localhost:8000/api/...')
                (r'axios\.(\w+)\s*\(\s*[\'"`]/api/', rf'axios.\1(`{self.fastapi_base_url}/api/'),
                # .get('/api/...') -> .get('http://localhost:8000/api/...')
                (r'\.(\w+)\s*\(\s*[\'"`]/api/', rf'.\1(`{self.fastapi_base_url}/api/'),
            ]
            
            for pattern, replacement in patterns_replacements:
                content = re.sub(pattern, replacement, content, flags=re.IGNORECASE)
            
            if content != original_content:
                # Create backup
                backup_path = file_path.with_suffix(file_path.suffix + '.backup')
                backup_path.write_text(original_content, encoding='utf-8')
                
                # Write updated content
                file_path.write_text(content, encoding='utf-8')
                
                self.changes_made.append({
                    'file': str(file_path),
                    'backup': str(backup_path),
                    'action': 'updated_api_calls'
                })
                
                return True
                
        except Exception as e:
            print(f"Error updating {file_path}: {e}")
            
        return False
    
    def create_api_config_file(self) -> bool:
        """Create a configuration file for API endpoints"""
        config_content = f"""// API Configuration
// This file was auto-generated by the FastAPI migration tool

export const API_CONFIG = {{
  BASE_URL: '{self.fastapi_base_url}',
  ENDPOINTS: {{
    STATUS: '/api/status',
    INIT: '/api/init',
    GOALS: '/api/goals',
    TASKS: '/api/tasks',
    PLANS: '/api/plans',
    CALENDAR: '/api/calendar',
    RELATIONSHIPS: '/api/relationships',
    GENERATE_PLAN: '/api/generate-plan',
    OVERRIDES: '/api/overrides'
  }}
}};

// Helper function to build full API URLs
export function buildApiUrl(endpoint) {{
  return `${{API_CONFIG.BASE_URL}}${{endpoint}}`;
}}

// Helper function for making API requests
export async function apiRequest(endpoint, options = {{}}) {{
  const url = buildApiUrl(endpoint);
  const defaultOptions = {{
    headers: {{
      'Content-Type': 'application/json',
      ...options.headers
    }}
  }};
  
  return fetch(url, {{ ...defaultOptions, ...options }});
}}
"""
        
        config_path = self.frontend_dir / "lib" / "api-config.js"
        config_path.parent.mkdir(exist_ok=True)
        
        try:
            config_path.write_text(config_content, encoding='utf-8')
            self.changes_made.append({
                'file': str(config_path),
                'action': 'created_api_config'
            })
            return True
        except Exception as e:
            print(f"Error creating API config: {e}")
            return False
    
    def update_next_config(self) -> bool:
        """Update Next.js config to proxy API requests to FastAPI"""
        next_config_path = self.frontend_dir / "next.config.js"
        
        if not next_config_path.exists():
            return False
        
        try:
            content = next_config_path.read_text(encoding='utf-8')
            original_content = content
            
            # Add API rewrites to proxy to FastAPI
            rewrite_config = f"""
  async rewrites() {{
    return [
      {{
        source: '/api/:path*',
        destination: '{self.fastapi_base_url}/api/:path*',
      }},
    ];
  }},"""
            
            # Insert rewrites into the config
            if "module.exports" in content:
                # Find the config object and add rewrites
                if "rewrites" not in content:
                    content = content.replace(
                        "module.exports = {",
                        f"module.exports = {{{rewrite_config}"
                    )
                    
                    # Create backup
                    backup_path = next_config_path.with_suffix('.js.backup')
                    backup_path.write_text(original_content, encoding='utf-8')
                    
                    next_config_path.write_text(content, encoding='utf-8')
                    
                    self.changes_made.append({
                        'file': str(next_config_path),
                        'backup': str(backup_path),
                        'action': 'added_api_proxy'
                    })
                    
                    return True
                    
        except Exception as e:
            print(f"Error updating next.config.js: {e}")
            
        return False
    
    def migrate_to_fastapi(self) -> Dict:
        """Migrate frontend to use FastAPI backend"""
        print("Starting frontend migration to FastAPI...")
        
        # Find all API calls
        api_calls = self.find_api_calls()
        print(f"Found API calls in {len(api_calls)} files")
        
        # Update API calls in files
        updated_files = 0
        for file_path, calls in api_calls:
            if self.update_api_calls_in_file(file_path):
                updated_files += 1
                print(f"Updated: {file_path}")
        
        # Create API configuration file
        if self.create_api_config_file():
            print("Created API configuration file")
        
        # Update Next.js config for proxying
        if self.update_next_config():
            print("Updated Next.js configuration")
        
        return {
            'success': True,
            'files_updated': updated_files,
            'changes_made': self.changes_made,
            'fastapi_url': self.fastapi_base_url
        }
    
    def rollback_changes(self) -> bool:
        """Rollback all changes made during migration"""
        print("Rolling back frontend changes...")
        
        success = True
        for change in self.changes_made:
            try:
                if change['action'] in ['updated_api_calls', 'added_api_proxy']:
                    # Restore from backup
                    backup_path = Path(change['backup'])
                    if backup_path.exists():
                        original_path = Path(change['file'])
                        original_path.write_text(backup_path.read_text(encoding='utf-8'), encoding='utf-8')
                        backup_path.unlink()  # Remove backup
                        print(f"Restored: {change['file']}")
                    
                elif change['action'] == 'created_api_config':
                    # Remove created file
                    config_path = Path(change['file'])
                    if config_path.exists():
                        config_path.unlink()
                        print(f"Removed: {change['file']}")
                        
            except Exception as e:
                print(f"Error rolling back {change['file']}: {e}")
                success = False
        
        self.changes_made.clear()
        return success

def main():
    """Main function for command-line usage"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Update frontend to use FastAPI backend")
    parser.add_argument("--migrate", action="store_true", help="Migrate to FastAPI")
    parser.add_argument("--rollback", action="store_true", help="Rollback to Next.js API")
    parser.add_argument("--port", type=int, default=8000, help="FastAPI port (default: 8000)")
    parser.add_argument("--frontend-dir", default="../app", help="Frontend directory path")
    
    args = parser.parse_args()
    
    updater = FrontendConfigUpdater(args.frontend_dir, args.port)
    
    if args.migrate:
        result = updater.migrate_to_fastapi()
        print(f"Migration result: {result}")
        
    elif args.rollback:
        success = updater.rollback_changes()
        print(f"Rollback {'successful' if success else 'failed'}")
        
    else:
        # Just find and report API calls
        api_calls = updater.find_api_calls()
        print(f"Found {len(api_calls)} files with API calls:")
        for file_path, calls in api_calls:
            print(f"  {file_path}: {len(calls)} calls")

if __name__ == "__main__":
    main()